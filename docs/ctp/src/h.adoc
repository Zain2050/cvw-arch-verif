
=== H Hypervisor

The Hypervisor Extension adds an H coverage file containing new Hypervisor instructions, and additional coverage files related to exceptions, interrupts, endian, and virtual memory.

[[t-H-normative-rules]]
.Hypervisor Normative Rules
[cols="1, 4, 2" options=header]
|===
|Priv Section|Normative Rule|Coverpoints
|21|CSR `mtval` must not be read-only zero|ZicsrH/mcsr/cp_mtvala
|21|RISC-V harts that implement the
hypervisor extension are encouraged not to hardwire `misa`[7], so that
the extension may be disabled.|Untestable
|21.1|VS-mode interrupts are globally disabled when executing in
U-mode.|InterruptsH/cp_vsint_disabled_u
|21.2|Additional CSRs are provided to HS-mode, but not to VS-mode,
to manage two-stage address translation and to control the behavior of a
VS-mode guest: `hstatus`, `hedeleg`, `hideleg`, `hvip`, `hip`, `hie`,
`hgeip`, `hgeie`, `henvcfg`, `henvcfgh`, `hcounteren`, `htimedelta`,
`htimedeltah`, `htval`, `htinst`, and `hgatp`.|ZicsrH/hcsr/cp_hcsr_access, vscsr/cp_hcsr_inaccessible
|21.2|When V=1, the VS CSRs substitute for the corresponding supervisor CSRs,
taking over all functions of the usual supervisor CSRs except as
specified otherwise. |See each VS CSR
|21.2|When V=1, ... Instructions that normally read or modify a
supervisor CSR shall instead access the corresponding VS CSR.|ZicsrH/vscsr/cp_replica
|21.2|When V=1,
an attempt to read or write a VS CSR directly by its own separate CSR
address causes a virtual-instruction exception.|ZicsrH/vscsr/cp_hcsr_virtualinstructionfault, vucsr/cp_scsr
|21.2|Attempts [to read or write a VS CSR] from U-mode
cause an illegal-instruction exception as usual.|ZicsrH/ucsr/cp_hcsr_inaccessible
|21.2|The VS CSRs can be
accessed as themselves only from M-mode or HS-mode.|Zicsr/mcsr/cp_hcsr_access, hcsr/cp_hcsr_access, vscsr/cp_hcsr_virtualinstructionfault, cp_scsr
|21.2|While V=1, the normal HS-level supervisor CSRs that are replaced by VS
CSRs retain their values but do not affect the behavior of the machine
unless specifically documented to do so.|ZicsrH/vscsr/cp_replica
|21.2|Conversely, when V=0, the VS
CSRs do not ordinarily affect the behavior of the machine other than
being readable and writable by CSR instructions.|Zicsr/hcsr/cp_replica, *** show no other effects
|21.2|Some standard supervisor CSRs (`senvcfg`, `scounteren`, and `scontext`,
possibly others) have no matching VS CSR. These supervisor CSRs continue
to have their usual function and accessibility even when V=1|Zicsr/vscsr/cp_nonreplica
|21.2|In this chapter, we use the term _HSXLEN_ to refer to the effective XLEN
when executing in HS-mode, and _VSXLEN_ to refer to the effective XLEN
when executing in VS-mode.|XLEN not tested
|21.2.1|The VSXL field controls the effective XLEN for VS-mode (known as
VSXLEN), which may differ from the XLEN for HS-mode (HSXLEN).|XLEN not tested
|21.2.1|When VTSR=1, an attempt in VS-mode to execute SRET raises a
virtual-instruction exception.|ExceptionsH/cp_virtual_instruction_vs
|21.2.1|When VTW=1 (and assuming `mstatus`.TW=0),
an attempt in VS-mode to execute WFI raises a virtual-instruction
exception if the WFI does not complete within an
implementation-specific, bounded time limit.|ExceptionsH/cp_virtual_instruction_vs
|21.2.1|When VTVM=1, an attempt in
VS-mode to execute SFENCE.VMA or SINVAL.VMA or to access CSR `satp`
raises a virtual-instruction exception.|ExceptionsH/cp_virtual_instruction_vs
|21.2.1|The VGEIN (Virtual Guest External Interrupt Number) field selects a
guest external interrupt source for VS-level external interrupts.|InterruptsH/cp_trigger_vsei_hgeip
|21.2.1|VGEIN
is a *WLRL* field that must be able to hold values between zero and the
maximum guest external interrupt number (known as GEILEN), inclusive.
|Zicsr/hcsr/cp_hstatus_vgein
|21.2.1|When VGEIN=0, no guest external interrupt source is selected for
VS-level external interrupts.|cp_hgeip0
|21.2.1|Field HU (Hypervisor in U-mode) controls whether the virtual-machine
load/store instructions, HLV, HLVX, and HSV, can be used also in U-mode.
When HU=1, these instructions can be executed in U-mode the same as in
HS-mode. When HU=0, all hypervisor instructions cause an
illegal-instruction exception in U-mode.|ZicsrH/uprivinst/cp_hinst
|21.2.1|The SPV bit (Supervisor Previous Virtualization mode) is written by the
implementation whenever a trap is taken into HS-mode. Just as the SPP
bit in `sstatus` is set to the (nominal) privilege mode at the time of
the trap, the SPV bit in `hstatus` is set to the value of the
virtualization mode V at the time of the trap. |ExceptionsH/cp_ecall_to_hs, cp_hedeleg, InterruptsH/cp_trigger_vs{e/t/s}i, InterruptsS/cp_trigger_*
|21.2.1|When an SRET instruction
is executed when V=0, V is set to SPV.|ZicsrH/mprivinst/cp_sret, ZicsrH/hprivinst/cp_sret
|21.2.1|When V=1 and a trap is taken into HS-mode, bit SPVP (Supervisor Previous
Virtual Privilege) is set to the nominal privilege mode at the time of
the trap, the same as `sstatus`.SPP.|ExceptionsH/cp_hedeleg, ExceptionsH/cp_ecall_to_hs
|21.2.1|But if V=0 before a trap, SPVP is
left unchanged on trap entry. |ExceptionsH/cp_hedeleg, ExceptionsH/cp_ecall_to_hs
|21.2.1|SPVP controls the effective privilege of
explicit memory accesses made by the virtual-machine load/store
instructions, HLV, HLVX, and HSV.|H/h*v tests***
|21.2.1|Field GVA (Guest Virtual Address) is written by the implementation
whenever a trap is taken into HS-mode. For any trap (breakpoint, address
misaligned, access fault, page fault, or guest-page fault) that writes a
guest virtual address to `stval`, GVA is set to 1. For any other trap
into HS-mode, GVA is set to 0.|ExceptionsH/cp_hedeleg, ***virtmemtests
|21.2.1|The VSBE bit is a *WARL* field that controls the endianness of explicit memory
accesses made from VS-mode. If VSBE=0, explicit load and store memory
accesses made from VS-mode are little-endian, and if VSBE=1, they are
big-endian.|EndianH/cp_cp_hstatus_vsbe_endianness
|21.2.1|VSBE also controls the endianness of all implicit accesses
to VS-level memory management data structures, such as page tables.|***virtmem endian; check this is adequately tested by VM/ms.5 about mstatus.SBE
|21.2.2|Register `hedeleg` is a 64-bit read/write register|ZicsrH/hcsr/cp_hcsr_access
|21.2.2|Register `hideleg` is an HSXLEN-bit read/write register|ZicsrH/hcsr/cp_hcsr_access
|21.2.2|A synchronous trap that has been delegated to HS-mode (using `medeleg`)
is further delegated to VS-mode if V=1 before the trap and the
corresponding `hedeleg` bit is set.|ExceptionsH/cp_hedeleg
|21.2.2|Each bit of `hedeleg` shall be
either writable or read-only zero. Many bits of `hedeleg` are required
specifically to be writable or zero|ZicsrH/mcsr/cp_hcsr_access
|21.2.2|Bit 0, corresponding to
instruction address-misaligned exceptions, must be writable if
IALIGN=32.|ZicsrH/hcsr/cp_hcsr_access
|21.2.2|When XLEN=32, `hedelegh` is a 32-bit read/write register
that aliases bits 63:32 of `hedeleg`.|ZicsrH/hcsr/cp_hcsr_access
|21.2.2|Register `hedelegh` does not exist when XLEN=64.|ZicsrH/mcsr/cp_illegalupper
|21.2.2|An interrupt that has been delegated to HS-mode (using `mideleg`) is
further delegated to VS-mode if the corresponding `hideleg` bit is set.|InterruptsH/cp_priority_deleg_vsi
|21.2.2|Among bits 15:0 of `hideleg`, bits 10, 6, and 2 (corresponding to the
standard VS-level interrupts) are writable, and bits 12, 9, 5, and 1
(corresponding to the standard S-level interrupts) are read-only zeros.|ZicsrH/hcsr/cp_hcsr_access
|21.2.2|When a virtual supervisor external interrupt (code 10) is delegated to
VS-mode, it is automatically translated by the machine into a supervisor
external interrupt (code 9) for VS-mode, including the value written to
`vscause` on an interrupt trap. Likewise, a virtual supervisor timer
interrupt (6) is translated into a supervisor timer interrupt (5) for
VS-mode, and a virtual supervisor software interrupt (2) is translated
into a supervisor software interrupt (1) for VS-mode.|cp_hideleg_hip_vs, cp_hideleg_hip_vu

*** following entries need coverpoints

|21.2.3|Register `hvip` is an HSXLEN-bit read/write register that a hypervisor
can write to indicate virtual interrupts intended for VS-mode. Bits of
`hvip` that are not writable are read-only zeros.|
|21.2.3|Bits VSEIP, VSTIP,
and VSSIP of `hvip` are writable.|
|21.2.3|Setting VSEIP=1 in `hvip` asserts a
VS-level external interrupt; setting VSTIP asserts a VS-level timer
interrupt; and setting VSSIP asserts a VS-level software interrupt.|
|21.2.3|Registers `hip` and `hie` are HSXLEN-bit read/write registers|
|21.2.3|For each writable bit in `sie`, the corresponding bit shall be read-only
zero in both `hip` and `hie`. Hence, the nonzero bits in `sie` and `hie`
are always mutually exclusive, and likewise for `sip` and `hip`.|
|21.2.3|An interrupt _i_ will trap to HS-mode whenever all of the following are
true: (a) either the current operating mode is HS-mode and the SIE bit
in the `sstatus` register is set, or the current operating mode has less
privilege than HS-mode; (b) bit _i_ is set in both `sip` and `sie`, or
in both `hip` and `hie`; and (c) bit _i_ is not set in `hideleg`.|
|21.2.3|If bit _i_ of `sie` is read-only zero, the same bit in register `hip`
may be writable or may be read-only. When bit _i_ in `hip` is writable,
a pending interrupt _i_ can be cleared by writing 0 to this bit. If
interrupt _i_ can become pending in `hip` but bit _i_ in `hip` is
read-only, then either the interrupt can be cleared by clearing bit _i_
of `hvip`, or the implementation must provide some other mechanism for
clearing the pending interrupt (which may involve a call to the
execution environment).|
|21.2.3|A bit in `hie` shall be writable if the corresponding interrupt can ever
become pending in `hip`. Bits of `hie` that are not writable shall be
read-only zero.|
|21.2.3|Bits `hip`.SGEIP and `hie`.SGEIE are the interrupt-pending and
interrupt-enable bits for guest external interrupts at supervisor level
(HS-level). SGEIP is read-only in `hip`, and is 1 if and only if the
bitwise logical-AND of CSRs `hgeip` and `hgeie` is nonzero in any bit.|
|21.2.3|Bits `hip`.VSEIP and `hie`.VSEIE are the interrupt-pending and
interrupt-enable bits for VS-level external interrupts. VSEIP is
read-only in `hip`, and is the logical-OR of these interrupt sources:

* bit VSEIP of `hvip`;
* the bit of `hgeip` selected by `hstatus`.VGEIN; and
* any other platform-specific external interrupt signal directed to
VS-level.|
|21.2.3|Bits `hip`.VSTIP and `hie`.VSTIE are the interrupt-pending and
interrupt-enable bits for VS-level timer interrupts. VSTIP is read-only
in `hip`, and is the logical-OR of `hvip`.VSTIP and any other
platform-specific timer interrupt signal directed to VS-level.|
|21.2.3|Bits `hip`.VSSIP and `hie`.VSSIE are the interrupt-pending and
interrupt-enable bits for VS-level software interrupts. VSSIP in `hip`
is an alias (writable) of the same bit in `hvip`.|
|21.2.3|Multiple simultaneous interrupts destined for HS-mode are handled in the
following decreasing priority order: SEI, SSI, STI, SGEI, VSEI, VSSI,
VSTI, LCOFI.|
|21.2.4|The `hgeip` register is an HSXLEN-bit read-only register, formatted as
shown in <<hgeipreg>>, that indicates pending guest
external interrupts for this hart. The `hgeie` register is an HSXLEN-bit
read/write register, formatted as shown in
<<hgeiereg>>, that contains enable bits for the
guest external interrupts at this hart. Guest external interrupt number
_i_ corresponds with bit _i_ in both `hgeip` and `hgeie`.|
|21.2.4|The number of bits implemented in `hgeip` and `hgeie` for guest external
interrupts is UNSPECIFIED and may be zero. This number is known as _GEILEN_. The
least-significant bits are implemented first, apart from bit 0. Hence,
if GEILEN is nonzero, bits GEILEN:1 shall be writable in `hgeie`, and
all other bit positions shall be read-only zeros in both `hgeip` and
`hgeie`.|
|21.2.4|Register `hgeie` selects the subset of guest external interrupts that
cause a supervisor-level (HS-level) guest external interrupt. The enable
bits in `hgeie` do not affect the VS-level external interrupt signal
selected from `hgeip` by `hstatus`.VGEIN.|
|21.2.5|The `henvcfg` CSR is a 64-bit read/write register, formatted
as shown in <<henvcfg>>, that controls
certain characteristics of the execution environment when virtualization
mode V=1.|
|21.2.5|If bit FIOM (Fence of I/O implies Memory) is set to one in `henvcfg`,
FENCE instructions executed when V=1 are modified so the requirement to
order accesses to device I/O implies also the requirement to order main
memory accesses. <<henvcfg-FIOM>> details the modified
interpretation of FENCE instruction bits PI, PO, SI, and SO when FIOM=1
and V=1.|
|21.2.5|Similarly, when FIOM=1 and V=1, if an atomic instruction that accesses a
region ordered as device I/O has its _aq_ and/or _rl_ bit set, then that
instruction is ordered as though it accesses both device I/O and memory.|
|21.2.5|The PBMTE bit controls whether the Svpbmt extension is available for use
in VS-stage address translation. When PBMTE=1, Svpbmt is available for
VS-stage address translation. When PBMTE=0, the implementation behaves
as though Svpbmt were not implemented for VS-stage address translation.
If Svpbmt is not implemented, PBMTE is read-only zero.|
|21.2.5|If the Svadu extension is implemented, the ADUE bit controls whether hardware
updating of PTE A/D bits is enabled for VS-stage address translation.
When ADUE=1, hardware updating of PTE A/D bits is enabled during VS-stage
address translation, and the implementation behaves as though the Svade
extension were not implemented for VS-mode address translation.
When ADUE=0, the implementation behaves as though Svade were implemented for
VS-stage address translation.
If Svadu is not implemented, ADUE is read-only zero.|
|21.2.5|The definition of the STCE field is furnished by the Sstc extension.|
|21.2.5|The definition of the CBZE field is furnished by the Zicboz extension.|
|21.2.5|The definitions of the CBCFE and CBIE fields are furnished by the Zicbom extension.|
|21.2.5|The definition of the PMM field is furnished by the Ssnpm extension.|
|21.2.5|The Zicfilp extension adds the `LPE` field in `henvcfg`. When the `LPE` field
is set to 1, the Zicfilp extension is enabled in VS-mode. When the `LPE` field
is 0, the Zicfilp extension is not enabled in VS-mode and the following rules
apply to VS-mode:

* The hart does not update the `ELP` state; it remains as `NO_LP_EXPECTED`.
* The `LPAD` instruction operates as a no-op.|

|21.2.5|The Zicfiss extension adds the `SSE` field in `henvcfg`. If the `SSE` field is
set to 1, the Zicfiss extension is activated in VS-mode. When the `SSE` field is
0, the Zicfiss extension remains inactive in VS-mode, and the following rules
apply when `V=1`:

* 32-bit Zicfiss instructions will revert to their behavior as defined by Zimop.
* 16-bit Zicfiss instructions will revert to their behavior as defined by Zcmop.
* The `pte.xwr=010b` encoding in VS-stage page tables becomes reserved.
* The `senvcfg.SSE` field will read as zero and is read-only.
* When `menvcfg.SSE` is one, `SSAMOSWAP.W/D` raises a virtual-instruction
  exception.|
|21.2.5|The Ssdbltrp extension adds the double-trap-enable (`DTE`) field in `henvcfg`.
When `henvcfg.DTE` is zero, the implementation behaves as though Ssdbltrp is not
implemented for VS-mode and the `vsstatus.SDT` bit is read-only zero.|
|21.2.5|When XLEN=32, `henvcfgh` is a
32-bit read/write register that aliases bits 63:32
of `henvcfg`. Register `henvcfgh` does not exist when
XLEN=64.|
|21.2.6|The counter-enable register `hcounteren` is a 32-bit register that
controls the availability of the hardware performance monitoring
counters to the guest virtual machine.|
|21.2.6|When the CY, TM, IR, or HPM_n_ bit in the `hcounteren` register is
clear, attempts to read the `cycle`, `time`, `instret`, or
`hpmcounter` _n_ register while V=1 will cause a virtual-instruction
exception if the same bit in `mcounteren` is 1. When one of these bits
is set, access to the corresponding register is permitted when V=1,
unless prevented for some other reason. In VU-mode, a counter is not
readable unless the applicable bits are set in both `hcounteren` and
`scounteren`.|
|21.2.6|`hcounteren` must be implemented. However, any of the bits may be
read-only zero, indicating reads to the corresponding counter will cause
an exception when V=1. Hence, they are effectively *WARL* fields.|
|21.2.7|The `htimedelta` CSR is a 64-bit read/write register that contains the delta
between the value of the `time` CSR and the value returned in VS-mode or
VU-mode. That is, reading the `time` CSR in VS or VU mode returns the
sum of the contents of `htimedelta` and the actual value of `time`.|
|21.2.7|When XLEN=32, `htimedeltah` is a 32-bit read/write register
that aliases bits 63:32 of `htimedelta`.
Register `htimedeltah` does not exist when XLEN=64.|
|21.2.7|If the `time` CSR is implemented, `htimedelta` (and `htimedeltah` for XLEN=32)
must be implemented.|
|21.2.8|The `htval` register is an HSXLEN-bit read/write register formatted as
shown in <<htvalreg>>. When a trap is taken into
HS-mode, `htval` is written with additional exception-specific
information, alongside `stval`, to assist software in handling the trap.|
|21.2.8|When a guest-page-fault trap is taken into HS-mode, `htval` is written
with either zero or the guest physical address that faulted, shifted
right by 2 bits. For other traps, `htval` is set to zero, but a future
standard or extension may redefine `htval's` setting for other traps.|
|21.2.8|A guest-page fault may arise due to an implicit memory access during
first-stage (VS-stage) address translation, in which case a guest
physical address written to `htval` is that of the implicit memory
access that faulted—for example, the address of a VS-level page table
entry that could not be read. (The guest physical address corresponding
to the original virtual address is unknown when VS-stage translation
fails to complete.) Additional information is provided in CSR `htinst`
to disambiguate such situations.|
|21.2.8|Otherwise, for misaligned loads and stores that cause guest-page faults,
a nonzero guest physical address in `htval` corresponds to the faulting
portion of the access as indicated by the virtual address in `stval`.
For instruction guest-page faults on systems with variable-length
instructions, a nonzero `htval` corresponds to the faulting portion of
the instruction as indicated by the virtual address in `stval`.|
|21.2.8|`htval` is a *WARL* register that must be able to hold zero and may be capable
of holding only an arbitrary subset of other 2-bit-shifted guest
physical addresses, if any.|
|21.2.9|The `htinst` register is an HSXLEN-bit read/write register formatted as
shown in <<htinstreg>>. When a trap is taken into
HS-mode, `htinst` is written with a value that, if nonzero, provides
information about the instruction that trapped, to assist software in
handling the trap. The values that may be written to `htinst` on a trap
are documented in <<tinst-vals>>.|
|21.2.9|`htinst` is a *WARL* register that need only be able to hold the values that
the implementation may automatically write to it on a trap.|
|21.2.10|The `hgatp` register is an HSXLEN-bit read/write register, formatted as
shown in <<rv32hgatp>> for HSXLEN=32 and
<<rv64hgatp>> for HSXLEN=64, which controls
G-stage address translation and protection, the second stage of
two-stage translation for guest virtual addresses (see
<<two-stage-translation>>). Similar to CSR `satp`, this
register holds the physical page number (PPN) of the guest-physical root
page table; a virtual machine identifier (VMID), which facilitates
address-translation fences on a per-virtual-machine basis; and the MODE
field, which selects the address-translation scheme for guest physical
addresses. When `mstatus`.TVM=1, attempts to read or write `hgatp` while
executing in HS-mode will raise an illegal-instruction exception.|
|21.2.10|<<hgatp-mode>> shows the encodings of the MODE field when
HSXLEN=32 and HSXLEN=64. When MODE=Bare, guest physical addresses are
equal to supervisor physical addresses, and there is no further memory
protection for a guest virtual machine beyond the physical memory
protection scheme described in <<pmp>>. In this
case, software must write zero to the remaining fields in `hgatp`.
Attempting to select MODE=Bare with a nonzero pattern in the remaining fields
has an UNSPECIFIED effect on the value that the remaining fields assume and an
UNSPECIFIED effect on G-stage address translation and protection behavior.|
|21.2.10|When HSXLEN=32, the only other valid setting for MODE is Sv32x4, which
is a modification of the usual Sv32 paged virtual-memory scheme,
extended to support 34-bit guest physical addresses.|
|21.2.10|When HSXLEN=64,
modes Sv39x4, Sv48x4, and Sv57x4 are defined as modifications of the
Sv39, Sv48, and Sv57 paged virtual-memory schemes. All of these paged
virtual-memory schemes are described in
<<guest-addr-translation>>.|
|21.2.10|The remaining MODE settings when HSXLEN=64 are reserved for future use
and may define different interpretations of the other fields in `hgatp`.|
|21.2.10|Implementations are not required to support all defined MODE settings
when HSXLEN=64|.
|21.2.10|A write to `hgatp` with an unsupported MODE value is not ignored as it
is for `satp`. Instead, the fields of `hgatp` are *WARL* in the normal way,
when so indicated.|
|21.2.10|As explained in <<guest-addr-translation>>, for the
paged virtual-memory schemes (Sv32x4, Sv39x4, Sv48x4, and Sv57x4), the
root page table is 16 KiB and must be aligned to a 16-KiB boundary. In
these modes, the lowest two bits of the physical page number (PPN) in
`hgatp` always read as zeros. An implementation that supports only the
defined paged virtual-memory schemes and/or Bare may make PPN[1:0]
read-only zero.|
|21.2.10|The number of VMID bits is UNSPECIFIED and may be zero. The number of implemented
VMID bits, termed _VMIDLEN_, may be determined by writing one to every
bit position in the VMID field, then reading back the value in `hgatp`
to see which bit positions in the VMID field hold a one. The
least-significant bits of VMID are implemented first: that is, if
VMIDLEN > 0, VMID[VMIDLEN-1:0] is writable. The maximal
value of VMIDLEN, termed VMIDMAX, is 7 for Sv32x4 or 14 for Sv39x4,
Sv48x4, and Sv57x4.|
|21.2.10|The `hgatp` register is considered _active_ for the purposes of the
address-translation algorithm _unless_ the effective privilege mode is U
and `hstatus`.HU=0.|
|21.2.11|The `vsstatus` register is a VSXLEN-bit read/write register that is
VS-mode’s version of supervisor register `sstatus`, formatted as shown
in <<vsstatusreg-rv32>> when VSXLEN=32 and
<<vsstatusreg>> when VSXLEN=64. When V=1,
`vsstatus` substitutes for the usual `sstatus`, so instructions that
normally read or modify `sstatus` actually access `vsstatus` instead.|
|21.2.11|The UXL field controls the effective XLEN for VU-mode, which may differ
from the XLEN for VS-mode (VSXLEN). When VSXLEN=32, the UXL field does
not exist, and VU-mode XLEN=32. When VSXLEN=64, UXL is a *WARL* field that is
encoded the same as the MXL field of `misa`, shown in <<misabase>>. In particular, an implementation may make UXL be a read-only copy of field VSXL of `hstatus`, forcing VU-mode XLEN=VSXLEN.|
|21.2.11|If VSXLEN is changed from 32 to a wider width, and if field UXL is not
restricted to a single value, it gets the value corresponding to the
widest supported width not wider than the new VSXLEN.|
|21.2.11|When V=1, both `vsstatus`.FS and the HS-level `sstatus`.FS are in
effect. Attempts to execute a floating-point instruction when either
field is 0 (Off) raise an illegal-instruction exception. Modifying the
floating-point state when V=1 causes both fields to be set to 3 (Dirty).|
|21.2.11|Similarly, when V=1, both `vsstatus`.VS and the HS-level `sstatus`.VS
are in effect. Attempts to execute a vector instruction when either
field is 0 (Off) raise an illegal-instruction exception. Modifying the
vector state when V=1 causes both fields to be set to 3 (Dirty).|
|21.2.11|Read-only fields SD and XS summarize the extension context status as it
is visible to VS-mode only. For example, the value of the HS-level
`sstatus`.FS does not affect `vsstatus`.SD.|
|21.2.11|An implementation may make field UBE be a read-only copy of
`hstatus`.VSBE.|
|21.2.11|When V=0, `vsstatus` does not directly affect the behavior of the
machine, unless a virtual-machine load/store (HLV, HLVX, or HSV) or the
MPRV feature in the `mstatus` register is used to execute a load or
store _as though_ V=1.|
|21.2.11|The Zicfilp extension adds the `SPELP` field that holds the previous `ELP`, and
is updated as specified in <<ZICFILP_FORWARD_TRAPS>>. The `SPELP` field is
encoded as follows:

* 0 - `NO_LP_EXPECTED` - no landing pad instruction expected.
* 1 - `LP_EXPECTED` - a landing pad instruction is expected.
|

|21.2.11|The Ssdbltrp adds an S-mode-disable-trap (`SDT`) field extension to address
double trap (See <<supv-double-trap>>) in VS-mode.|
|21.2.12|The `vsip` and `vsie` registers are VSXLEN-bit read/write registers that
are VS-mode’s versions of supervisor CSRs `sip` and `sie`, formatted as
shown in <<vsipreg>> and <<vsiereg>>
respectively. When V=1, `vsip` and `vsie` substitute for the usual `sip`
and `sie`, so instructions that normally read or modify `sip`/`sie`
actually access `vsip`/`vsie` instead. However, interrupts directed to
HS-level continue to be indicated in the HS-level `sip` register, not in
`vsip`, when V=1.|
|21.2.12|Extension Shlcofideleg supports delegating LCOFI interrupts to VS-mode.
If the Shlcofideleg extension is implemented, `hideleg` bit 13 is
writable; otherwise, it is read-only zero.
When bit 13 of `hideleg` is zero, `vsip`.LCOFIP and `vsie`.LCOFIE
are read-only zeros.
Else, `vsip`.LCOFIP and `vsie`.LCOFIE are aliases of `sip`.LCOFIP
and `sie`.LCOFIE.|
|21.2.12|When bit 10 of `hideleg` is zero, `vsip`.SEIP and `vsie`.SEIE are
read-only zeros. Else, `vsip`.SEIP and `vsie`.SEIE are aliases of
`hip`.VSEIP and `hie`.VSEIE.|
|21.2.12|When bit 6 of `hideleg` is zero, `vsip`.STIP and `vsie`.STIE are
read-only zeros. Else, `vsip`.STIP and `vsie`.STIE are aliases of
`hip`.VSTIP and `hie`.VSTIE.|
|21.2.12|When bit 2 of `hideleg` is zero, `vsip`.SSIP and `vsie`.SSIE are
read-only zeros. Else, `vsip`.SSIP and `vsie`.SSIE are aliases of
`hip`.VSSIP and `hie`.VSSIE.|
|21.2.13|The `vstvec` register is a VSXLEN-bit read/write register that is
VS-mode’s version of supervisor register `stvec`, formatted as shown in
<<vstvecreg>>. When V=1, `vstvec` substitutes for
the usual `stvec`, so instructions that normally read or modify `stvec`
actually access `vstvec` instead. When V=0, `vstvec` does not directly
affect the behavior of the machine.|
|21.2.14|The `vsscratch` register is a VSXLEN-bit read/write register that is
VS-mode’s version of supervisor register `sscratch`, formatted as shown
in <<vsscratchreg>>. When V=1, `vsscratch`
substitutes for the usual `sscratch`, so instructions that normally read
or modify `sscratch` actually access `vsscratch` instead. The contents
of `vsscratch` never directly affect the behavior of the machine.|
|21.2.15|The `vsepc` register is a VSXLEN-bit read/write register that is
VS-mode’s version of supervisor register `sepc`, formatted as shown in
<<vsepcreg>>. When V=1, `vsepc` substitutes for the
usual `sepc`, so instructions that normally read or modify `sepc`
actually access `vsepc` instead. When V=0, `vsepc` does not directly
affect the behavior of the machine.|
|21.2.15|`vsepc` is a *WARL* register that must be able to hold the same set of values
that `sepc` can hold.|
|21.2.16|The `vscause` register is a VSXLEN-bit read/write register that is
VS-mode’s version of supervisor register `scause`, formatted as shown in
<<vscausereg>>. When V=1, `vscause` substitutes
for the usual `scause`, so instructions that normally read or modify
`scause` actually access `vscause` instead. When V=0, `vscause` does not
directly affect the behavior of the machine.|
|21.2.16|`vscause` is a *WLRL* register that must be able to hold the same set of
values that `scause` can hold.|
|21.2.17|The `vstval` register is a VSXLEN-bit read/write register that is
VS-mode’s version of supervisor register `stval`, formatted as shown in
<<vstvalreg>>. When V=1, `vstval` substitutes for
the usual `stval`, so instructions that normally read or modify `stval`
actually access `vstval` instead. When V=0, `vstval` does not directly
affect the behavior of the machine.|
|21.2.17|`vstval` is a *WARL* register that must be able to hold the same set of values
that `stval` can hold.|
|21.2.18|The `vsatp` register is a VSXLEN-bit read/write register that is
VS-mode’s version of supervisor register `satp`, formatted as shown in
<<rv32vsatpreg>> for VSXLEN=32 and <<rv64vsatpreg>> for VSXLEN=64. When V=1,
`vsatp` substitutes for the usual `satp`, so instructions that normally
read or modify `satp` actually access `vsatp` instead. `vsatp` controls
VS-stage address translation, the first stage of two-stage translation
for guest virtual addresses (see
<<two-stage-translation>>).|
|21.2.18|The `vsatp` register is considered _active_ for the purposes of the
address-translation algorithm _unless_ the effective privilege mode is U
and `hstatus`.HU=0. However, even when `vsatp` is active, VS-stage
page-table entries’ A bits must not be set as a result of speculative
execution, unless the effective privilege mode is VS or VU.|
|21.2.18|When V=0, a write to `vsatp` with an unsupported MODE value is either
ignored as it is for `satp`, or the fields of `vsatp` are treated as *WARL* in
the normal way. However, when V=1, a write to `satp` with an unsupported
MODE value _is_ ignored and no write to `vsatp` is effected.|
|21.2.18|When V=0, `vsatp` does not directly affect the behavior of the machine,
unless a virtual-machine load/store (HLV, HLVX, or HSV) or the MPRV
feature in the `mstatus` register is used to execute a load or store _as
though_ V=1.|
|21.3.1|
The hypervisor virtual-machine load and store instructions are valid
only in M-mode or HS-mode, or in U-mode when `hstatus`.HU=1. Each
instruction performs an explicit memory access with an effective privilege mode
of VS or VU. The effective privilege mode of the explicit memory access is VU
when `hstatus`.SPVP=0, and VS when `hstatus`.SPVP=1. As usual for VS-mode and
VU-mode, two-stage address translation is applied, and
the HS-level `sstatus`.SUM is ignored. HS-level `sstatus`.MXR makes
execute-only pages readable by explicit loads for both stages of address translation
(VS-stage and G-stage), whereas `vsstatus`.MXR affects only the first
translation stage (VS-stage).|
|21.3.1|For every RV32I or RV64I load instruction, LB, LBU, LH, LHU, LW, LWU,
and LD, there is a corresponding virtual-machine load instruction:
HLV.B, HLV.BU, HLV.H, HLV.HU, HLV.W, HLV.WU, and HLV.D. For every RV32I
or RV64I store instruction, SB, SH, SW, and SD, there is a corresponding
virtual-machine store instruction: HSV.B, HSV.H, HSV.W, and HSV.D.
Instructions HLV.WU, HLV.D, and HSV.D are not valid for RV32, of course.|
|21.3.1|Instructions HLVX.HU and HLVX.WU are the same as HLV.HU and HLV.WU,
except that _execute_ permission takes the place of _read_ permission
during address translation. That is, the memory being read must be
executable in both stages of address translation, but read permission is
not required. For the supervisor physical address that results from
address translation, the supervisor physical memory attributes must
grant both _execute_ and _read_ permissions. (The _supervisor physical
memory attributes_ are the machine’s physical memory attributes as
modified by physical memory protection, <<pmp>>, for
supervisor level.)|
|21.3.1|HLVX.WU is valid for RV32, even though LWU and HLV.WU are not. (For
RV32, HLVX.WU can be considered a variant of HLV.W, as sign extension is
irrelevant for 32-bit values.)|
|21.3.1|Attempts to execute a virtual-machine load/store instruction (HLV, HLVX,
or HSV) when V=1 cause a virtual-instruction exception. Attempts to execute
one of these same instructions from U-mode when `hstatus`.HU=0 cause an
illegal-instruction exception.|
|21.3.2|The hypervisor memory-management fence instructions, HFENCE.VVMA and
HFENCE.GVMA, perform a function similar to SFENCE.VMA
(<<sfence.vma>>), except applying to the
VS-level memory-management data structures controlled by CSR `vsatp`
(HFENCE.VVMA) or the guest-physical memory-management data structures
controlled by CSR `hgatp` (HFENCE.GVMA). Instruction SFENCE.VMA applies
only to the memory-management data structures controlled by the current
`satp` (either the HS-level `satp` when V=0 or `vsatp` when V=1).|
|21.3.2|HFENCE.VVMA is valid only in M-mode or HS-mode. Its effect is much the
same as temporarily entering VS-mode and executing SFENCE.VMA. Executing
an HFENCE.VVMA guarantees that any previous stores already visible to
the current hart are ordered before all implicit reads by that hart done
for VS-stage address translation for instructions that

* are subsequent to the HFENCE.VVMA, and
* execute when `hgatp`.VMID has the same setting as it did when
HFENCE.VVMA executed.
|
|21.3.2|Implicit reads need not be ordered when `hgatp`.VMID is different than
at the time HFENCE.VVMA executed. If operand __rs1__≠`x0`, it specifies a single guest virtual address, and if operand __rs2__≠`x0`, it specifies a single guest address-space identifier (ASID).|
|21.3.2|When __rs2__≠`x0`, bits XLEN-1:ASIDMAX of the value held
in _rs2_ are reserved for future standard use. Until their use is
defined by a standard extension, they should be zeroed by software and
ignored by current implementations. Furthermore, if
ASIDLEN < ASIDMAX, the implementation shall ignore bits
ASIDMAX-1:ASIDLEN of the value held in _rs2_.|
|21.3.2|Neither `mstatus`.TVM nor `hstatus`.VTVM causes HFENCE.VVMA to trap.|
|21.3.2|HFENCE.GVMA is valid only in HS-mode when `mstatus`.TVM=0, or in M-mode
(irrespective of `mstatus`.TVM). Executing an HFENCE.GVMA instruction
guarantees that any previous stores already visible to the current hart
are ordered before all implicit reads by that hart done for G-stage
address translation for instructions that follow the HFENCE.GVMA. If
operand __rs1__≠`x0`, it specifies a single guest
physical address, shifted right by 2 bits, and if operand
__rs2__≠`x0`, it specifies a single virtual machine
identifier (VMID).|
|21.3.2|When __rs2__≠`x0`, bits XLEN-1:VMIDMAX of the value held
in _rs2_ are reserved for future standard use. Until their use is
defined by a standard extension, they should be zeroed by software and
ignored by current implementations. Furthermore, if
VMIDLEN < VMIDMAX, the implementation shall ignore bits
VMIDMAX-1:VMIDLEN of the value held in _rs2_|
|21.3.2|If `hgatp`.MODE is changed for a given VMID, an HFENCE.GVMA with
_rs1_=`x0` (and _rs2_ set to either `x0` or the VMID) must be executed
to order subsequent guest translations with the MODE change—even if the
old MODE or new MODE is Bare.|
|21.3.2|Attempts to execute HFENCE.VVMA or HFENCE.GVMA when V=1 cause a
virtual-instruction exception, while attempts to do the same in U-mode cause an
illegal-instruction exception. Attempting to execute HFENCE.GVMA in HS-mode
when `mstatus`.TVM=1 also causes an illegal-instruction exception.|
|21.4.1|The hypervisor extension adds two fields, MPV and GVA, to the
machine-level `mstatus` or `mstatush` CSR, and modifies the behavior of
several existing `mstatus` fields.
<<hypervisor-mstatus>> shows the modified
`mstatus` register when the hypervisor extension is implemented and
MXLEN=64. When MXLEN=32, the hypervisor extension adds MPV and GVA not
to `mstatus` but to `mstatush`.
<<hypervisor-mstatush>> shows the
`mstatush` register when the hypervisor extension is implemented and
MXLEN=32.|
|21.4.1|The MPV bit (Machine Previous Virtualization Mode) is written by the
implementation whenever a trap is taken into M-mode. Just as the MPP
field is set to the (nominal) privilege mode at the time of the trap,
the MPV bit is set to the value of the virtualization mode V at the time
of the trap. When an MRET instruction is executed, the virtualization
mode V is set to MPV, unless MPP=3, in which case V remains 0.|
|21.4.1|Field GVA (Guest Virtual Address) is written by the implementation
whenever a trap is taken into M-mode. For any trap (breakpoint, address
misaligned, access fault, page fault, or guest-page fault) that writes a
guest virtual address to `mtval`, GVA is set to 1. For any other trap
into M-mode, GVA is set to 0.|
|21.4.1|The TSR and TVM fields of `mstatus` affect execution only in HS-mode,
not in VS-mode. The TW field affects execution in all modes except
M-mode.|
|21.4.1|Setting TVM=1 prevents HS-mode from accessing `hgatp` or executing
HFENCE.GVMA or HINVAL.GVMA, but has no effect on accesses to `vsatp` or
instructions HFENCE.VVMA or HINVAL.VVMA.|
|21.4.1|The hypervisor extension changes the behavior of the Modify Privilege
field, MPRV, of `mstatus`. When MPRV=0, translation and protection
behave as normal. When MPRV=1, explicit memory accesses are translated
and protected, and endianness is applied, as though the current
virtualization mode were set to MPV and the current nominal privilege
mode were set to MPP. <<h-mprv>> enumerates the cases.|
|21.4.1|MPRV does not affect the virtual-machine load/store instructions, HLV,
HLVX, and HSV. The explicit loads and stores of these instructions
always act as though V=1 and the nominal privilege mode were
`hstatus`.SPVP, overriding MPRV.|
|21.4.1|The `mstatus` register is a superset of the HS-level `sstatus` register
but is not a superset of `vsstatus`.|
|21.4.2|When the hypervisor extension is implemented, bits 10, 6, and 2 of
`mideleg` (corresponding to the standard VS-level interrupts) are each
read-only one. Furthermore, if any guest external interrupts are
implemented (GEILEN is nonzero), bit 12 of `mideleg` (corresponding to
supervisor-level guest external interrupts) is also read-only one.
VS-level interrupts and guest external interrupts are always delegated
past M-mode to HS-mode.|
|21.4.2|For bits of `mideleg` that are zero, the corresponding bits in
`hideleg`, `hip`, and `hie` are read-only zeros.|
|21.4.3|Bits SGEIP, VSEIP, VSTIP, and VSSIP in `mip` are aliases for the same
bits in hypervisor CSR `hip`, while SGEIE, VSEIE, VSTIE, and VSSIE in
`mie` are aliases for the same bits in `hie`.|
|21.4.4|The `mtval2` register is an MXLEN-bit read/write register formatted as
shown in <<mtval2reg>>. When a trap is taken into
M-mode, `mtval2` is written with additional exception-specific
information, alongside `mtval`, to assist software in handling the trap.|
|21.4.4|When a guest-page-fault trap is taken into M-mode, `mtval2` is written
with either zero or the guest physical address that faulted, shifted
right by 2 bits. For other traps, `mtval2` is set to zero, but a future
standard or extension may redefine `mtval2's` setting for other traps.|
|21.4.4|If a guest-page fault is due to an implicit memory access during
first-stage (VS-stage) address translation, a guest physical address
written to `mtval2` is that of the implicit memory access that faulted.
Additional information is provided in CSR `mtinst` to disambiguate such
situations.|
|21.4.4|Otherwise, for misaligned loads and stores that cause guest-page faults,
a nonzero guest physical address in `mtval2` corresponds to the faulting
portion of the access as indicated by the virtual address in `mtval`.
For instruction guest-page faults on systems with variable-length
instructions, a nonzero `mtval2` corresponds to the faulting portion of
the instruction as indicated by the virtual address in `mtval`.|
|21.4.4|`mtval2` is a *WARL* register that must be able to hold zero and may be
capable of holding only an arbitrary subset of other 2-bit-shifted guest
physical addresses, if any.|
|21.4.4|The Ssdbltrap extension (See <<ssdbltrp>>) requires the implementation of
the `mtval2` CSR.|
|21.4.5|The `mtinst` register is an MXLEN-bit read/write register formatted as
shown in <<mtinstreg>>. When a trap is taken into
M-mode, `mtinst` is written with a value that, if nonzero, provides
information about the instruction that trapped, to assist software in
handling the trap. The values that may be written to `mtinst` on a trap
are documented in <<tinst-vals>>.|
|21.4.5|`mtinst` is a *WARL* register that need only be able to hold the values that
the implementation may automatically write to it on a trap.|
|22.5|Whenever the current virtualization mode V is 1, two-stage address
translation and protection is in effect. For any virtual memory access,
the original virtual address is converted in the first stage by VS-level
address translation, as controlled by the `vsatp` register, into a
_guest physical address_. The guest physical address is then converted
in the second stage by guest physical address translation, as controlled
by the `hgatp` register, into a supervisor physical address. The two
stages are known also as VS-stage and G-stage translation. Although
there is no option to disable two-stage address translation when V=1,
either stage of translation can be effectively disabled by zeroing the
corresponding `vsatp` or `hgatp` register.|
|22.5|The `vsstatus` field MXR, which makes execute-only pages readable by explicit loads, only
overrides VS-stage page protection. Setting MXR at VS-level does not
override guest-physical page protections. Setting MXR at HS-level,
however, overrides both VS-stage and G-stage execute-only permissions.|
|22.5|When V=1, memory accesses that would normally bypass address translation
are subject to G-stage address translation alone. This includes memory
accesses made in support of VS-stage address translation, such as reads
and writes of VS-level page tables.|
|22.5|Machine-level physical memory protection applies to supervisor physical
addresses and is in effect regardless of virtualization mode.|
|22.5.1|The mapping of guest physical addresses to supervisor physical addresses
is controlled by CSR `hgatp` (<<hgatp>>).|
|22.5.1|When the address translation scheme selected by the MODE field of
`hgatp` is Bare, guest physical addresses are equal to supervisor
physical addresses without modification, and no memory protection
applies in the trivial translation of guest physical addresses to
supervisor physical addresses.|
|22.5.1|When `hgatp`.MODE specifies a translation scheme of Sv32x4, Sv39x4,
Sv48x4, or Sv57x4, G-stage address translation is a variation on the
usual page-based virtual address translation scheme of Sv32, Sv39, Sv48,
or Sv57, respectively. In each case, the size of the incoming address is
widened by 2 bits (to 34, 41, 50, or 59 bits). To accommodate the
2 extra bits, the root page table (only) is expanded by a factor of four
to be 16 KiB instead of the usual 4 KiB. Matching its larger size, the
root page table also must be aligned to a 16 KiB boundary instead of the
usual 4 KiB page boundary. Except as noted, all other aspects of Sv32,
Sv39, Sv48, or Sv57 are adopted unchanged for G-stage translation.
Non-root page tables and all page table entries (PTEs) have the same
formats as documented in <<sv32>>, <<sv39>>, <<sv48>>, and <<sv57>>.|
|22.5.1|For Sv32x4, an incoming guest physical address is partitioned into a
virtual page number (VPN) and page offset as shown in
<<sv32x4va>>. This partitioning is identical to
that for an Sv32 virtual address as depicted in
<<sv32va>>, except with 2 more bits at the
high end in VPN[1]. (Note that the fields of a partitioned guest
physical address also correspond one-for-one with the structure that
Sv32 assigns to a physical address, depicted in
<<sv32va>>.)|
|22.5.1|For Sv39x4, an incoming guest physical address is partitioned as shown
in <<sv39x4va>>. This partitioning is identical to that for an Sv39 virtual address as depicted in <<sv39va>>, except with 2 more bits at the
high end in VPN[2]. Address bits 63:41 must all be zeros, or else a
guest-page-fault exception occurs.|
|22.5.1|For Sv48x4, an incoming guest physical address is partitioned as shown
in <<sv48x4va>>. This partitioning is identical to
that for an Sv48 virtual address as depicted in
<<sv48va>>, except with 2 more bits at the
high end in VPN[3]. Address bits 63:50 must all be zeros, or else a
guest-page-fault exception occurs.|
|22.5.1|For Sv57x4, an incoming guest physical address is partitioned as shown
in <<sv57x4va>>. This partitioning is identical to
that for an Sv57 virtual address as depicted in
<<sv57va>>, except with 2 more bits at the
high end in VPN[4]. Address bits 63:59 must all be zeros, or else a
guest-page-fault exception occurs.|
|22.5.1|The conversion of an Sv32x4, Sv39x4, Sv48x4, or Sv57x4 guest physical
address is accomplished with the same algorithm used for Sv32, Sv39,
Sv48, or Sv57, as presented in
<<sv32algorithm>>, except that:

* `hgatp` substitutes for the usual `satp`;
* for the translation to begin, the effective privilege mode must be
VS-mode or VU-mode;
* when checking the U bit, the current privilege mode is always taken to
be U-mode; and
* guest-page-fault exceptions are raised instead of regular page-fault
exceptions.|
|22.5.1|For G-stage address translation, all memory accesses (including those
made to access data structures for VS-stage address translation) are
considered to be user-level accesses, as though executed in U-mode.
Access type permissions—readable, writable, or executable—are checked
during G-stage translation the same as for VS-stage translation. For a
memory access made to support VS-stage address translation (such as to
read/write a VS-level page table), permissions and the need to set A
and/or D bits at the G-stage level are checked as though for an implicit
load or store, not for the original access type. However, any exception
is always reported for the original access type (instruction, load, or
store/AMO).|
|22.5.1|The G bit in all G-stage PTEs is currently not used. Until
its use is defined by a standard extension, it should be cleared by
software for forward compatibility, and must be ignored by hardware.|
|22.5.2|Guest-page-fault traps may be delegated from M-mode to HS-mode under the
control of CSR `medeleg`, but cannot be delegated to other privilege
modes. On a guest-page fault, CSR `mtval` or `stval` is written with the
faulting guest virtual address as usual, and `mtval2` or `htval` is
written either with zero or with the faulting guest physical address,
shifted right by 2 bits. CSR `mtinst` or `htinst` may also be written
with information about the faulting instruction or other reason for the
access, as explained in <<tinst-vals>>.|
|22.5.2|When an instruction fetch or a misaligned memory access straddles a page
boundary, two different address translations are involved. When a
guest-page fault occurs in such a circumstance, the faulting virtual
address written to `mtval`/`stval` is the same as would be required for
a regular page fault. Thus, the faulting virtual address may be a
page-boundary address that is higher than the instruction's original
virtual address, if the byte at that page boundary is among the accessed
bytes.|
|22.5.2|When a guest-page fault is not due to an implicit memory access for
VS-stage address translation, a nonzero guest physical address written
to `mtval2`/`htval` shall correspond to the exact virtual address
written to `mtval`/`stval`.|
|22.5.3|The behavior of the SFENCE.VMA instruction is affected by the current
virtualization mode V. When V=0, the virtual-address argument is an
HS-level virtual address, and the ASID argument is an HS-level ASID. The
instruction orders stores only to HS-level address-translation
structures with subsequent HS-level address translations.|
|22.5.3|When V=1, the virtual-address argument to SFENCE.VMA is a guest virtual
address within the current virtual machine, and the ASID argument is a
VS-level ASID within the current virtual machine. The current virtual
machine is identified by the VMID field of CSR `hgatp`, and the
effective ASID can be considered to be the combination of this VMID with
the VS-level ASID. The SFENCE.VMA instruction orders stores only to the
VS-level address-translation structures with subsequent VS-stage address
translations for the same virtual machine, i.e., only when `hgatp`.VMID
is the same as when the SFENCE.VMA executed.|
|22.5.3|Hypervisor instructions HFENCE.VVMA and HFENCE.GVMA provide additional
memory-management fences to complement SFENCE.VMA. These instructions
are described in <<hfence.vma>>.|
|22.5.3|<<pmp-vmem>> discusses the intersection between
physical memory protection (PMP) and page-based address translation. It
is noted there that, when PMP settings are modified in a manner that
affects either the physical memory that holds page tables or the
physical memory to which page tables point, M-mode software must
synchronize the PMP settings with the virtual memory system. For
HS-level address translation, this is accomplished by executing in
M-mode an SFENCE.VMA instruction with _rs1_=`x0` and _rs2_=`x0`, after
the PMP CSRs are written. Synchronization with G-stage and VS-stage data
structures is also needed. Executing an HFENCE.GVMA instruction with
_rs1_=`x0` and _rs2_=`x0` suffices to flush all G-stage or VS-stage
address-translation cache entries that have cached PMP settings
corresponding to the final translated supervisor physical address. An
HFENCE.VVMA instruction is not required.|
|22.5.3|Similarly, if the setting of the PBMTE bit in `menvcfg` is changed, an
HFENCE.GVMA instruction with _rs1_=`x0` and _rs2_=`x0` suffices to synchronize
with respect to the altered interpretation of G-stage and VS-stage PTEs' PBMT
fields.|
|22.5.3|By contrast, if the PBMTE bit in `henvcfg` is changed, executing an
HFENCE.VVMA with _rs1_=`x0` and _rs2_=`x0` suffices to synchronize with
respect to the altered interpretation of VS-stage PTEs' PBMT fields for the
currently active VMID.|
|22.6.1|The hypervisor extension augments the trap cause encoding.
<<hcauses>> lists the possible M-mode and HS-mode
trap cause codes when the hypervisor extension is implemented. Codes are
added for VS-level interrupts (interrupts 2, 6, 10), for
supervisor-level guest external interrupts (interrupt 12), for
virtual-instruction exceptions (exception 22), and for guest-page faults
(exceptions 20, 21, 23). Furthermore, environment calls from VS-mode are
assigned cause 10, whereas those from HS-mode or S-mode use cause 9 as
usual.|
|22.6.1|HS-mode and VS-mode ECALLs use different cause values so they can be
delegated separately.|
|22.6.1|When V=1, a virtual-instruction exception (code 22) is normally raised
instead of an illegal-instruction exception if the attempted instruction
is _HS-qualified_ but is prevented from executing when V=1 either due to
insufficient privilege or because the instruction is expressly disabled
by a supervisor or hypervisor CSR such as `scounteren` or `hcounteren`.
An instruction is _HS-qualified_ if it would be valid to execute in
HS-mode (for some values of the instruction's register operands),
assuming fields TSR and TVM of CSR `mstatus` are both zero.|
|22.6.1|A special rule applies for CSR instructions that access 32-bit high-half
CSRs such as `cycleh` and `htimedeltah`. When V=1 and
XLEN=32, an invalid attempt to access a high-half CSR
raises a virtual-instruction
exception instead of an illegal-instruction exception if the same CSR
instruction for the corresponding _low-half_ CSR (e.g.`cycle` or
`htimedelta`) is HS-qualified.|
|22.6.1|When XLEN>32, an attempt to access a high-half CSR
always raises an illegal-instruction exception.|
|22.6.1|Specifically, a virtual-instruction exception is raised for the
following cases:

* in VS-mode, attempts to access a non-high-half counter CSR when the
corresponding bit in `hcounteren` is 0 and the same bit in `mcounteren`
is 1;
* in VS-mode, if XLEN=32, attempts to access a high-half counter CSR
when the corresponding bit in `hcounteren` is 0 and the same bit in
`mcounteren` is 1;
* in VU-mode, attempts to access a non-high-half counter CSR when the
corresponding bit in either `hcounteren` or `scounteren` is 0 and the
same bit in `mcounteren` is 1;
* in VU-mode, if XLEN=32, attempts to access a high-half counter CSR
when the corresponding bit in either `hcounteren` or `scounteren` is 0
and the same bit in `mcounteren` is 1;
* in VS-mode or VU-mode, attempts to execute a hypervisor instruction
(HLV, HLVX, HSV, or HFENCE);
* in VS-mode or VU-mode, attempts to access an implemented non-high-half
hypervisor CSR or VS CSR when the same access (read/write) would be
allowed in HS-mode, assuming `mstatus`.TVM=0;
* in VS-mode or VU-mode, if XLEN=32, attempts to access an implemented
high-half hypervisor CSR or high-half VS CSR when the same access
(read/write) to the CSR"s low-half partner would be allowed in HS-mode,
assuming `mstatus`.TVM=0;
* in VU-mode, attempts to execute WFI when `mstatus`.TW=0, or to execute
a supervisor instruction (SRET or SFENCE);
* in VU-mode, attempts to access an implemented non-high-half supervisor
CSR when the same access (read/write) would be allowed in HS-mode,
assuming `mstatus`.TVM=0;
* in VU-mode, if XLEN=32, attempts to access an implemented high-half
supervisor CSR when the same access to the CSR's low-half partner would
be allowed in HS-mode, assuming `mstatus`.TVM=0;
* in VS-mode, attempts to execute WFI when `hstatus`.VTW=1 and
`mstatus`.TW=0, unless the instruction completes within an
implementation-specific, bounded time;
* in VS-mode, attempts to execute SRET when `hstatus`.VTSR=1; and
* in VS-mode, attempts to execute an SFENCE.VMA or SINVAL.VMA
instruction or to access `satp`, when `hstatus`.VTVM=1.
|
|22.6.1|On a virtual-instruction trap, `mtval` or `stval` is written the same as
for an illegal-instruction trap.|
|22.6.1|Fields FS and VS in registers `sstatus` and `vsstatus` deviate from the usual
_HS-qualified_ rule.
If an instruction is prevented from executing because FS or VS is zero in
either `sstatus` or `vsstatus`, the exception raised is always an
illegal-instruction exception, never a virtual-instruction exception.|
|22.6.1|If an instruction may raise multiple synchronous exceptions, the
decreasing priority order of <<HSyncExcPrio>>
indicates which exception is taken and reported in `mcause` or `scause`.|
|22.6.2|When a trap occurs in HS-mode or U-mode, it goes to M-mode, unless
delegated by `medeleg` or `mideleg`, in which case it goes to HS-mode.
When a trap occurs in VS-mode or VU-mode, it goes to M-mode, unless
delegated by `medeleg` or `mideleg`, in which case it goes to HS-mode,
unless further delegated by `hedeleg` or `hideleg`, in which case it
goes to VS-mode.|

|22.6.2|When a trap is taken into M-mode, virtualization mode V gets set to 0,
and fields MPV and MPP in `mstatus` (or `mstatush`) are set according to
<<h-mpp>>. A trap into M-mode also writes fields GVA,
MPIE, and MIE in `mstatus`/`mstatush` and writes CSRs `mepc`, `mcause`,
`mtval`, `mtval2`, and `mtinst`.|
|22.6.2|When a trap is taken into HS-mode, virtualization mode V is set to 0,
and `hstatus`.SPV and `sstatus`.SPP are set according to
<<h-spp>>. If V was 1 before the trap, field SPVP in
`hstatus` is set the same as `sstatus`.SPP; otherwise, SPVP is left
unchanged. A trap into HS-mode also writes field GVA in `hstatus`,
fields SPIE and SIE in `sstatus`, and CSRs `sepc`, `scause`, `stval`,
`htval`, and `htinst`.|
|22.6.2|When a trap is taken into VS-mode, `vsstatus`.SPP is set according to
<<h-vspp>>. Register `hstatus` and the HS-level
`sstatus` are not modified, and the virtualization mode V remains 1. A
trap into VS-mode also writes fields SPIE and SIE in `vsstatus` and
writes CSRs `vsepc`, `vscause`, and `vstval`.|
|22.6.3|On any trap into M-mode or HS-mode, one of these values is written
automatically into the appropriate trap instruction CSR, `mtinst` or
`htinst`:

* zero;
* a transformation of the trapping instruction;
* a custom value (allowed only if the trapping instruction is
non-standard); or
* a special pseudoinstruction.|

|22.6.3|Except when a pseudoinstruction value is required (described later), the
value written to `mtinst` or `htinst` may always be zero, indicating
that the hardware is providing no information in the register for this
particular trap.|
|22.6.3|On an interrupt, the value written to the trap instruction register is
always zero. On a synchronous exception, if a nonzero value is written,
one of the following shall be true about the value:

* Bit 0 is `1`, and replacing bit 1 with `1` makes the value into a
valid encoding of a standard instruction.
+
In this case, the instruction that trapped is the same kind as indicated
by the register value, and the register value is the transformation of
the trapping instruction, as defined later. For example, if bits 1:0 are
binary `11` and the register value is the encoding of a standard LW
(load word) instruction, then the trapping instruction is LW, and the
register value is the transformation of the trapping LW instruction.
* Bit 0 is `1`, and replacing bit 1 with `1` makes the value into an
instruction encoding that is explicitly designated for a custom
instruction (_not_ an unused reserved encoding).
+
This is a _custom value_. The instruction that trapped is a non-standard
instruction. The interpretation of a custom value is not otherwise
specified by this standard.
* The value is one of the special pseudoinstructions defined later, all
of which have bits 1:0 equal to `00`.|
|22.6.3|<<tinst-values>> shows the values that may be
automatically written to the trap instruction register for each standard
exception cause. For exceptions that prevent the fetching of an
instruction, only zero or a pseudoinstruction value may be written. A
custom value may be automatically written only if the instruction that
traps is non-standard. A future standard or extension may permit other
values to be written, chosen from the set of allowed values established
earlier.|
|22.6.3|For a standard load instruction that is not a compressed instruction and
is one of LB, LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH, the
transformed instruction has the format shown in
<<transformedloadinst>>.|
|22.6.3|For a standard store instruction that is not a compressed instruction
and is one of SB, SH, SW, SD, FSW, FSD, FSQ, or FSH, the transformed
instruction has the format shown in
<<transformedstoreinst>>.|
|22.6.3|For a standard atomic instruction (load-reserved, store-conditional, or AMO instruction), the transformed instruction has the format shown in <<transformedatomicinst>>.|
|22.6.3|For a standard virtual-machine load/store instruction (HLV, HLVX, or HSV), the transformed instruction has the format shown in <<transformedvmaccessinst>>.|
|22.6.3|For a standard compressed instruction (16-bit size), the transformed
instruction is found as follows:

. Expand the compressed instruction to its 32-bit equivalent.
. Transform the 32-bit equivalent instruction.
. Replace bit 1 with a `0`.
|
|22.6.3|For guest-page faults, the trap instruction register is written with a
special pseudoinstruction value if: (a) the fault is caused by an
implicit memory access for VS-stage address translation, and (b) a
nonzero value (the faulting guest physical address) is written to
`mtval2` or `htval`. If both conditions are met, the value written to
`mtinst` or `htinst` must be taken from
<<pseudoinsts>>; zero is not allowed.|
|22.6.3|A _write_ pseudoinstruction (`0x00002020` or `0x00003020`) is used for
the case that the machine is attempting automatically to update bits A
and/or D in VS-level page tables. All other implicit memory accesses for
VS-stage address translation will be reads. If a machine never
automatically updates bits A or D in VS-level page tables (leaving this
to software), the _write_ case will never arise. The fact that such a
page table update must actually be atomic, not just a simple write, is
ignored for the pseudoinstruction.|
|22.6.4|The MRET instruction is used to return from a trap taken into M-mode.
MRET first determines what the new privilege mode will be according to
the values of MPP and MPV in `mstatus` or `mstatush`, as encoded in
<<h-mpp>>. MRET then in `mstatus`/`mstatush` sets
MPV=0, MPP=0, MIE=MPIE, and MPIE=1. Lastly, MRET sets the privilege mode
as previously determined, and sets `pc`=`mepc`.|
|22.6.4|The SRET instruction is used to return from a trap taken into HS-mode or
VS-mode. Its behavior depends on the current virtualization mode.|
|22.6.4|When executed in M-mode or HS-mode (i.e., V=0), SRET first determines
what the new privilege mode will be according to the values in
`hstatus`.SPV and `sstatus`.SPP, as encoded in
<<h-spp>>. SRET then sets `hstatus`.SPV=0, and in
`sstatus` sets SPP=0, SIE=SPIE, and SPIE=1. Lastly, SRET sets the
privilege mode as previously determined, and sets `pc`=`sepc`.|
|22.6.4|When executed in VS-mode (i.e., V=1), SRET sets the privilege mode
according to <<h-vspp>>, in `vsstatus` sets SPP=0,
SIE=SPIE, and SPIE=1, and lastly sets `pc`=`vsepc`.|
|22.6.4|If the Ssdbltrp extension is implemented, when `SRET` is executed in HS-mode,
if the new privilege mode is VU, the `SRET` instruction sets `vsstatus.SDT`
to 0. When executed in VS-mode, `vsstatus.SDT` is set to 0.|
|===


==== H Hypervisor Instructions

[[t-H-coverpoints]]
.H Coverpoints
,===
//include::{testplansdir}/H.adoc[]
,===
https://docs.google.com/spreadsheets/d/1DWBEoprndjQzLTXQTzPI8jW1HydtkYRR3tg58q59fdk/edit?gid=2001628267#gid=2001628267[Google Sheet Testplan]

==== ZicsrH Hypervisor CSRs

[[t-ZicsrH-coverpoints]]
.ZicsrH Coverpoints
,===
//include::{testplansdir}/ZicsrH.adoc[]
,===
https://docs.google.com/spreadsheets/d/1DWBEoprndjQzLTXQTzPI8jW1HydtkYRR3tg58q59fdk/edit?gid=262865576#gid=262865576[Google Sheet Testplan]

==== ExceptionsH Hypervisor Exceptions

[[t-ExceptionsH-coverpoints]]
.ExceptionsH Coverpoints
,===
//include::{testplansdir}/ExceptionsH.adoc[]
,===
https://docs.google.com/spreadsheets/d/1DWBEoprndjQzLTXQTzPI8jW1HydtkYRR3tg58q59fdk/edit?gid=1980169189#gid=1980169189[Google Sheet Testplan]

==== ExceptionsHV Hypervisor Vector Exceptions

[[t-ExceptionsHV-coverpoints]]
.ExceptionsHV Coverpoints
,===
//include::{testplansdir}/ExceptionsHV.adoc[]
,===
https://docs.google.com/spreadsheets/d/1DWBEoprndjQzLTXQTzPI8jW1HydtkYRR3tg58q59fdk/edit?gid=552219666#gid=552219666[Google Sheet Testplan]

==== InterruptsH Hypervisor Interrupts

[[t-InterruptsH-coverpoints]]
.InterruptsH Coverpoints
,===
//include::{testplansdir}/InterruptsH.adoc[]
,===
https://docs.google.com/spreadsheets/d/1DWBEoprndjQzLTXQTzPI8jW1HydtkYRR3tg58q59fdk/edit?gid=552831967#gid=552831967[Google Sheet Testplan]

==== EndianH Hypervisor Endianness

[[t-EndianH-coverpoints]]
.EndianH Coverpoints
,===
//include::{testplansdir}/EndianH.adoc[]
,===
https://docs.google.com/spreadsheets/d/1DWBEoprndjQzLTXQTzPI8jW1HydtkYRR3tg58q59fdk/edit?gid=923631685#gid=923631685[Google Sheet Testplan]

==== ZicntrH Hypervisor Counters

[[t-ZicntrH-coverpoints]]
.ZicntrH Coverpoints
,===
//include::{testplansdir}/ZicntrH.adoc[]
,===
https://docs.google.com/spreadsheets/d/1DWBEoprndjQzLTXQTzPI8jW1HydtkYRR3tg58q59fdk/edit?gid=2079344243#gid=2079344243[Google Sheet Testplan]

[NOTE]
====
ZicntrH exercises hcounteren for all 32 counters, so no separate ZihpmH suite is needed.
====

==== PMPH Hypervisor Physical Memory Protection

[[t-PMPH-coverpoints]]
.PMPH Coverpoints
,===
//include::{testplansdir}/PMPH.adoc[]
,===
https://docs.google.com/spreadsheets/d/1DWBEoprndjQzLTXQTzPI8jW1HydtkYRR3tg58q59fdk/edit?gid=161540329#gid=161540329[Google Sheet Testplan]

==== RV32VMH Hypervisor 2-Stage Virtual Memory

[[t-RV32VMH-coverpoints]]
.RV32VMH Coverpoints
,===
//include::{testplansdir}/RV32VMH.adoc[]
,===
https://docs.google.com/spreadsheets/d/1DWBEoprndjQzLTXQTzPI8jW1HydtkYRR3tg58q59fdk/edit?gid=747120884#gid=747120884[Google Sheet Testplan]

==== RV32VMH_CBO Hypervisor VM + Cache Block Operations

[[t-RV32VMH_CBO-coverpoints]]
.RV32VMH_CBO Coverpoints
,===
//include::{testplansdir}/RV32VMH_CBO.adoc[]
,===
https://docs.google.com/spreadsheets/d/1DWBEoprndjQzLTXQTzPI8jW1HydtkYRR3tg58q59fdk/edit?gid=2005939128#gid=2005939128[Google Sheet Testplan]

==== RV64VMH Hypervisor 2-Stage Virtual Memory

Virtual memory behavior introduced by Hypervisor extension.

[[t-RV64VMH-coverpoints]]
.RV64VMH Coverpoints
,===
//include::{testplansdir}/RV64VMH.adoc[]
,===
https://docs.google.com/spreadsheets/d/1DWBEoprndjQzLTXQTzPI8jW1HydtkYRR3tg58q59fdk/edit?gid=1056442231#gid=1056442231[Google Sheet Testplan]

==== RV64VMH_CBO Hypervisor VM + Cache Block Operations

Virtual memory / CBO behavior introduced by Hypervisor extension.

[[t-RV64VMH_CBO-coverpoints]]
.RV64VMH_CBO Coverpoints
,===
//include::{testplansdir}/RV64VMH_CBO.adoc[]
,===
https://docs.google.com/spreadsheets/d/1DWBEoprndjQzLTXQTzPI8jW1HydtkYRR3tg58q59fdk/edit?gid=216799752#gid=216799752[Google Sheet Testplan]

==== Shcounterenw Writable Counter Enables

[[t-Shcounterenw-coverpoints]]
.Shcounterenw Coverpoints
,===
//include::{testplansdir}/Shcounterenw.adoc[]
,===
https://docs.google.com/spreadsheets/d/1DWBEoprndjQzLTXQTzPI8jW1HydtkYRR3tg58q59fdk/edit?gid=359491363#gid=359491363[Google Sheet Testplan]

==== Shvsatpa Virtual Memory Modes Supported

[[t-Shvsatpa-coverpoints]]
.Shvsatpa Coverpoints
,===
//include::{testplansdir}/Shvsatpa.adoc[]
,===
https://docs.google.com/spreadsheets/d/1DWBEoprndjQzLTXQTzPI8jW1HydtkYRR3tg58q59fdk/edit?gid=1777147736#gid=1777147736[Google Sheet Testplan]

==== Shgatpa Virtual Memory x4 Modes Supported

[[t-Shgatpa-coverpoints]]
.Shgatpa Coverpoints
,===
//include::{testplansdir}/Shgatpa.adoc[]
,===
https://docs.google.com/spreadsheets/d/1DWBEoprndjQzLTXQTzPI8jW1HydtkYRR3tg58q59fdk/edit?gid=262220701#gid=262220701[Google Sheet Testplan]

==== Shvstvecd VS-Mode Direct Vectors

[[t-Shvstvecd-coverpoints]]
.Shvstvecd Coverpoints
,===
//include::{testplansdir}/Shvstvecd.adoc[]
,===
https://docs.google.com/spreadsheets/d/1DWBEoprndjQzLTXQTzPI8jW1HydtkYRR3tg58q59fdk/edit?gid=1109621355#gid=1109621355[Google Sheet Testplan]

==== Shvstvala VS-Mode Trap Address

[[t-Shvstvala-coverpoints]]
.Shvstvala Coverpoints
,===
//include::{testplansdir}/Shvstvala.adoc[]
,===
https://docs.google.com/spreadsheets/d/1DWBEoprndjQzLTXQTzPI8jW1HydtkYRR3tg58q59fdk/edit?gid=970539312#gid=970539312[Google Sheet Testplan]

==== Shtvala HS-Mode Trap Address

[[t-Shtvala-coverpoints]]
.Shtvala Coverpoints
,===
//include::{testplansdir}/Shtvala.adoc[]
,===
https://docs.google.com/spreadsheets/d/1DWBEoprndjQzLTXQTzPI8jW1HydtkYRR3tg58q59fdk/edit?gid=1365004927#gid=1365004927[Google Sheet Testplan]

==== Shlcofideleg Hypervisor Counter Overflow Delegation

[[t-Shlcofideleg-coverpoints]]
.Shlcofideleg Coverpoints
,===
//include::{testplansdir}/Shlcofideleg.adoc[]
,===
https://docs.google.com/spreadsheets/d/1DWBEoprndjQzLTXQTzPI8jW1HydtkYRR3tg58q59fdk/edit?gid=820648507#gid=820648507[Google Sheet Testplan]

==== ZkrH Hypervisor Entropy Register

[[t-ZkrH-coverpoints]]
.ZkrH Coverpoints
,===
//include::{testplansdir}/ZkrH.adoc[]
,===
https://docs.google.com/spreadsheets/d/1DWBEoprndjQzLTXQTzPI8jW1HydtkYRR3tg58q59fdk/edit?gid=443731814#gid=443731814[Google Sheet Testplan]

==== SstcH Hypervisor Timer Compare

[[t-SstcH-coverpoints]]
.SstcH Coverpoints
,===
//include::{testplansdir}/SstcH.adoc[]
,===
https://docs.google.com/spreadsheets/d/1DWBEoprndjQzLTXQTzPI8jW1HydtkYRR3tg58q59fdk/edit?gid=1537373133#gid=1537373133[Google Sheet Testplan]

==== SsstateenH Hypervisor State Enable

[[t-SsstateenH-coverpoints]]
.SsstateenH Coverpoints
,===
//include::{testplansdir}/SsstateenH.adoc[]
,===
https://docs.google.com/spreadsheets/d/1DWBEoprndjQzLTXQTzPI8jW1HydtkYRR3tg58q59fdk/edit?gid=311784014#gid=311784014[Google Sheet Testplan]

==== SscrindH Hypervisor Indirect CSR Access

Hypervisor indirect CSR access.

[[t-SscrindH-coverpoints]]
.SscrindH Coverpoints
,===
//include::{testplansdir}/SscrindH.adoc[]
,===
https://docs.google.com/spreadsheets/d/1DWBEoprndjQzLTXQTzPI8jW1HydtkYRR3tg58q59fdk/edit?gid=886109861#gid=886109861[Google Sheet Testplan]

==== SscfgH Hypervisor Counter Delegation

[[t-SscfgH-coverpoints]]
.SscfgH Coverpoints
,===
//include::{testplansdir}/SscfgH.adoc[]
,===
https://docs.google.com/spreadsheets/d/1DWBEoprndjQzLTXQTzPI8jW1HydtkYRR3tg58q59fdk/edit?gid=2089644586#gid=2089644586[Google Sheet Testplan]

==== SmctrH Hypervisor Control Transfer Records

[[t-SmctrH-coverpoints]]
.SmctrH Coverpoints
,===
//include::{testplansdir}/SmctrH.adoc[]
,===
https://docs.google.com/spreadsheets/d/1DWBEoprndjQzLTXQTzPI8jW1HydtkYRR3tg58q59fdk/edit?gid=858128446#gid=858128446[Google Sheet Testplan]

==== SvinvalH Hypervisor Memory Management Table Invalidation

[[t-SvinvalH-coverpoints]]
.SvinvalH Coverpoints
,===
//include::{testplansdir}/SvinvalH.adoc[]
,===
https://docs.google.com/spreadsheets/d/1DWBEoprndjQzLTXQTzPI8jW1HydtkYRR3tg58q59fdk/edit?gid=292965592#gid=292965592[Google Sheet Testplan]

==== SvaduH Hypervisor Hardware Page Table A/D Updates

[[t-SvaduH-coverpoints]]
.SvaduH Coverpoints
,===
//include::{testplansdir}/SvaduH.adoc[]
,===
https://docs.google.com/spreadsheets/d/1DWBEoprndjQzLTXQTzPI8jW1HydtkYRR3tg58q59fdk/edit?gid=530717859#gid=530717859[Google Sheet Testplan]

==== ZicfilpH Hypervisor Landing Pads

[[t-ZicfilpH-coverpoints]]
.ZicfilpH Coverpoints
,===
//include::{testplansdir}/ZicfilpH.adoc[]
,===
https://docs.google.com/spreadsheets/d/1DWBEoprndjQzLTXQTzPI8jW1HydtkYRR3tg58q59fdk/edit?gid=1214579712#gid=1214579712[Google Sheet Testplan]

==== ZicfissH Hypervisor Shadow Stack

[[t-ZicfissH-coverpoints]]
.ZicfissH Coverpoints
,===
//include::{testplansdir}/ZicfissH.adoc[]
,===
https://docs.google.com/spreadsheets/d/1DWBEoprndjQzLTXQTzPI8jW1HydtkYRR3tg58q59fdk/edit?gid=890828729#gid=890828729[Google Sheet Testplan]

==== SsdbltrpH Hypervisor Double Trap

[[t-SsdbltrpH-coverpoints]]
.SsdbltrpH Coverpoints
,===
//include::{testplansdir}/SsdbltrpH.adoc[]
,===
https://docs.google.com/spreadsheets/d/1DWBEoprndjQzLTXQTzPI8jW1HydtkYRR3tg58q59fdk/edit?gid=1156592509#gid=1156592509[Google Sheet Testplan]

==== SsnpmH Hypervisor Pointer Masking

[[t-SsnpmH-coverpoints]]
.SsnpmH Coverpoints
,===
//include::{testplansdir}/SsnpmH.adoc[]
,===
https://docs.google.com/spreadsheets/d/1DWBEoprndjQzLTXQTzPI8jW1HydtkYRR3tg58q59fdk/edit?gid=669410459#gid=669410459[Google Sheet Testplan]

==== SmnpmH Hypervisor Pointer Masking

[[t-SmnpmH-coverpoints]]
.SmnpmH Coverpoints
,===
//include::{testplansdir}/SmnpmH.adoc[]
,===
https://docs.google.com/spreadsheets/d/1DWBEoprndjQzLTXQTzPI8jW1HydtkYRR3tg58q59fdk/edit?gid=1162472491#gid=1162472491[Google Sheet Testplan]
