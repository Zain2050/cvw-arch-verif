
=== I Base Integer Extension

<<t-I-coverpoints>> summarizes the coverpoints for the I extension.  The Type column is used to generate tests with the appropriate operands. An x in the RV32 or RV64 colunn indicates that the instruction is supported in that XLEN.  The remaining columns refer to coverpoints defined in <<t-unprivileged-coverpoints>>.

[[t-I-coverpoints]]
.I Instruction Coverpoints
include::{testplansdir}/I.adoc[]

[[t-I-modified-coverpoints]]
.I Modified Coverpoints
[cols="2, 1, 4" options=header]
|===
|Modified Coverpoint|Bins|Definition
|cp_rs1_nx0|31|The rs1 register number used in the instruction, excluding x0.  x0 is hardwired to 0, which results in potentially access faults for loads, stores, and jalr.
|cmp_rd_rs1_nx0|31|See cp_rs1_nx0
|cp_offset_jalr|6|cp_offset + 2*2 combinations of rs1_val[0] and imm[0] affecting lsb of jalr address
|cp_uimm_5|32|5-bit unsigned immediate shift amount for {slliw/srliw/sraiw}
|cp_imm_edges_20bit|27|20-bit variant of <<t-immediate-edge-definitions>> for `lui` and `auipc`.
|cp_imm_edges_jal|23|20-bit positive and negative jump offsets for `jal`.  Note that testing the full 20-bit range takes a large amount of program memory, so tests may cover a subset of this range.
|cp_gpr_hazard_r|2|RAR and no hazard for instructions that only write a register
|cp_gpr_hazard_w|3|WAW, WAR and no hazard for instructions that only write a register
|cp_gpr_hazard_rw|4|RAW, WAW, WAR and no hazard for instructions that read and write registers
|cp_align_{byte/hword/word}|8/4/2|Alignment of naturally-aligned load/store operand within doubleword in memory
|cp_custom_fence|3|Test that fence, fence rw,rw, and fence.tso all execute without trapping.
|===

<<t-I-normative-rules>> summarizes the normative rules in the RV{32/64}I specification and the unprivileged coverpoints that exercise them.  Privileged coverpoints related to integer instructions are described in the relevent parts of <<Privileged Test Plan>>. Note that the testplans always test the following fundamental capabilities, even if no normative rule is cited:

* Opcodes (cp_asm_count)
* All Source and Destination Registers (cp_rs1, cp_rs2, cp_rd)
* Edge values (cp_rs1_edges, cp_rs2_edges, cp_imm_edges, cr_rs1_rs2_edges, cr_rs1_imm_edges)
* All other bitfields in the instruction

[[t-I-normative-rules]]
.I Normative Rules
[cols="1, 4, 2" options=header]
|===
|Unpriv Section|Normative Rule|Coverpoints
|2.1|For RV32I, the 32 `x` registers are each 32 bits wide, i.e., `XLEN=32`.| cp_rs1, cp_rs2, cp_rd, cp_rs1_edges
|2.1|Register `x0` is hardwired with all bits equal to 0.|cp_rs1, cp_rs2, cp_rd
|2.2|In the base RV32I ISA, there are four core instruction formats (R/I/S/U)|cp_asm_count
|2.2|Except for the 5-bit immediates used in CSR instructions (Chapter 6), immediates are always sign-extended|cp_imm_edges
|2.2|Each immediate subfield is labeled with the bit position (imm[x]) in
the immediate value being produced.|cp_imm_edges
|2.3|The only difference between the S and B formats is that the 12-bit
immediate field is used to encode branch offsets in multiples of 2 in
the B format. Instead of shifting all bits in the instruction-encoded
immediate left by one in hardware as is conventionally done, the middle
bits (imm[10:1]) and sign bit stay in fixed positions, while the lowest
bit in S format (inst[7]) encodes a high-order bit in B format.|{store/branch}/cp_imm_edges
|2.3|[T]he only difference between the U and J formats is that the
20-bit immediate is shifted left by 12 bits to form U immediates and by
1 bit to form J immediates. The location of instruction bits in the U
and J format immediates is chosen to maximize overlap with the other
formats and with each other.|{lui/jalr}/cp_imm_edges
|2.3|Sign extensions always uses inst[31].|cp_imm_edges
|2.4|Most integer computational instructions operate on XLEN bits of values held in the integer register file.|cp_rs1, cp_rs2, cr_rs1_rs2_edges
|2.4|Integer computational instructions are either encoded as register-immediate operations using the I-type format or as register-register operations using the R-type format.|cp_rs1, cp_cp_rs1_imm_edges
|2.4|The destination is register rd for both register-immediate and register-register instructions.|cp_rd
|2.4|No integer computational instructions cause arithmetic exceptions.|No such exceptions exist, so nothing to test.
|2.4.1|ADDI adds the sign-extended 12-bit immediate to register _rs1_.
Arithmetic overflow is ignored and the result is simply the low XLEN
bits of the result.|addi/cp_rs1_imm_edges
|2.4.1|SLTI (set less than immediate) places the value 1 in register _rd_ if
register _rs1_ is less than the sign-extended immediate when both are
treated as signed numbers, else 0 is written to _rd_.|slti/cp_rs1_imm_edges
|2.4.1|SLTIU is similar
but compares the values as unsigned numbers (i.e., the immediate is
first sign-extended to XLEN bits then treated as an unsigned number).|sltiu/cp_rs1_imm_edges
|2.4.1|ANDI, ORI, XORI are logical operations that perform bitwise AND, OR, and
XOR on register _rs1_ and the sign-extended 12-bit immediate and place
the result in _rd_.|{andi/ori/xori}/cp_rs1_imm_edges
|2.4.1|Shifts by a constant are encoded as a specialization of the I-type
format. The operand to be shifted is in _rs1_, and the shift amount is
encoded in the lower 5 bits of the I-immediate field. The right shift
type is encoded in bit 30. SLLI is a logical left shift (zeros are
shifted into the lower bits); SRLI is a logical right shift (zeros are
shifted into the upper bits); and SRAI is an arithmetic right shift (the
original sign bit is copied into the vacated upper bits).|{slli/srli/srai}/cp_rs1_imm_edges, cp_uimm
|2.4.1|LUI (load upper immediate) is used to build 32-bit constants and uses
the U-type format. LUI places the 32-bit U-immediate value into the
destination register _rd_, filling in the lowest 12 bits with zeros.|lui/cp_imm_edges_20bit, cp_rd
|2.4.1|AUIPC (add upper immediate to `pc`) is used to build `pc`-relative
addresses and uses the U-type format. AUIPC forms a 32-bit offset from
the U-immediate, filling in the lowest 12 bits with zeros, adds this
offset to the address of the AUIPC instruction, then places the result
in register _rd_.|auipc/cp_imm_edges_20bit, cp_rd
|2.4.2|RV32I defines several arithmetic R-type operations. All operations read
the _rs1_ and _rs2_ registers as source operands and write the result
into register _rd_. The _funct7_ and _funct3_ fields select the type of
operation.|cr_rs1_rs2_edges, cp_rs1, cp_rs2, cp_rd
|2.4.2|ADD performs the addition of _rs1_ and _rs2_.|add/cp_rs1_rs2_edges
|2.4.2|SUB performs the
subtraction of _rs2_ from _rs1_. Overflows are ignored and the low XLEN
bits of results are written to the destination _rd_. |sub/cp_rs1_rs2_edges
|2.4.2|SLT and SLTU
perform signed and unsigned compares respectively, writing 1 to _rd_ if
_rs1_ < _rs2_, 0 otherwise.|{slt/sltu}/cp_rs1_rs2_edges
|2.4.2|AND, OR, and XOR perform bitwise
logical operations.|{and/or/xor}/cp_rs1_rs2_edges
|2.4.2|SLL, SRL, and SRA perform logical left, logical right, and arithmetic
right shifts on the value in register _rs1_ by the shift amount held in
the lower 5 bits of register _rs2_.|{sll/srl/sra}/cp_rs1_rs2_edges, cp_rs2
|2.4.3|The NOP instruction does not change any architecturally visible state,
except for advancing the `pc` and incrementing any applicable
performance counters. NOP is encoded as ADDI _x0, x0, 0_.|addi/cp_rs1_imm_edges
|2.5.1|The jump and link (JAL) instruction uses the J-type format, where the
J-immediate encodes a signed offset in multiples of 2 bytes. The offset
is sign-extended and added to the address of the jump instruction to
form the jump target address.|jal/cp_imm_edges_jal
|2.5.1|Plain unconditional jumps (assembler pseudoinstruction J) are encoded as
a JAL with _rd_=`x0`.|jal/cp_rd
|2.5.1|The indirect jump instruction JALR (jump and link register) uses the
I-type encoding. The target address is obtained by adding the
sign-extended 12-bit I-immediate to the register _rs1_, then setting the
least-significant bit of the result to zero. The address of the
instruction following the jump (`pc`+4) is written to register _rd_.
Register `x0` can be used as the destination if the result is not
required.|jalr/{cp_offset_jalr, cp_rd, cp_imm_edges}
|2.5.2|All branch instructions use the B-type instruction format. The 12-bit
B-immediate encodes signed offsets in multiples of 2 bytes. The offset
is sign-extended and added to the address of the branch instruction to
give the target address.|{beq/bne/blt/bge/bltu/bgeu}/cp_imm_edges_branch
|2.5.2|BEQ and BNE take the branch
if registers _rs1_ and _rs2_ are equal or unequal respectively.|{beq/bne}/cr_rs1_rs2_edges_offset
|2.5.2|BLT and
BLTU take the branch if _rs1_ is less than _rs2_, using signed and
unsigned comparison respectively. |{blt/bltu}/cr_rs1_rs2_edges_offset
|2.5.2|BGE and BGEU take the branch if _rs1_
is greater than or equal to _rs2_, using signed and unsigned comparison
respectively.|{bge/bgeu}/cr_rs1_rs2_edges_offset
|2.6|The effective address is obtained by adding register _rs1_ to the
sign-extended 12-bit offset.|cp_imm_edges
|2.6|Loads copy a value from memory to register
_rd_.|{lb/lbu/lh/lhu/lw}/{cp_rd}
|2.6|Stores copy the value in register _rs2_ to memory.|{sb/sh/sw}/{cp_rs2}
|2.6|The LW instruction loads a 32-bit value from memory into _rd_.|{cp_rd}
|2.6|LH loads
a 16-bit value from memory, then sign-extends to 32-bits before storing
in _rd_. LHU loads a 16-bit value from memory but then zero extends to
32-bits before storing in _rd_. LB and LBU are defined analogously for
8-bit values.|{lh/lhu/lb/lbu}/{cp_rd} hits these with random values.  32 random values is sufficient to ensure sign and zero extension are taking place.
|2.6|The SW, SH, and SB instructions store 32-bit, 16-bit, and
8-bit values from the low bits of register _rs2_ to memory.|{sw/sh/sb}/cp_rs2_edges
|2.6|loads and stores whose effective addresses are
naturally aligned shall not raise an address-misaligned exception.|untestable
|2.7|FENCE instructions are used to order device I/O and memory accesses as
viewed by other RISC-V harts and external devices or coprocessors.|fence/cp_asm_count; behavior untestable from a single core
|2.9|Implementations are always allowed to ignore the
encoded hints.|Untested because they may not be implemented.
3+^|RV64-Specific Statements
|4.1|RV64I widens the integer registers and supported user address space to 64 bits|cp_rs1, cp_rs2, cp_rs1_rs2_edges
|4.2.1|ADDIW is an RV64I instruction that adds the sign-extended 12-bit immediate to register rs1 and produces the proper sign extension of a 32-bit result in rd. Overflows are ignored and the result is the low 32 bits of the result sign-extended to 64 bits.|cp_rs1_imm_edges
|4.2.1|Shifts by a constant are encoded as a specialization of the I-type format using the same instruction opcode as RV32I. The operand to be shifted is in rs1, and the shift amount is encoded in the lower 6 bits of the I-immediate field for RV64I. The right shift type is encoded in bit 30. SLLI is a logical left shift (zeros are shifted into the lower bits); SRLI is a logical right shift (zeros are shifted into the upper bits); and SRAI is an arithmetic right shift (the original sign bit is copied into the vacated upper bits).|{slli/srli/srai}/cp_rs1_imm_edges, cp_uimm
|4.2.1|SLLIW, SRLIW, and SRAIW are RV64I-only instructions that are analogously
defined but operate on 32-bit values and sign-extend their 32-bit
results to 64 bits.|{slliw/srliw/sraiw}/cp_rs1_imm_edges, cp_uimm
|4.2.1|LUI (load upper immediate) uses the same opcode as RV32I. LUI places the
32-bit U-immediate into register _rd_, filling in the lowest 12 bits
with zeros. The 32-bit result is sign-extended to 64 bits.|lui/cp_imm_edges_20bit, cp_rd
|4.2.1|AUIPC (add upper immediate to `pc`) uses the same opcode as RV32I. AUIPC
is used to build `pc`-relative addresses and uses the U-type format.
AUIPC forms a 32-bit offset from the U-immediate, filling in the lowest
12 bits with zeros, sign-extends the result to 64 bits, adds it to the
address of the AUIPC instruction, then places the result in register
_rd_.|auipc/cp_imm_edges_20bit, cp_rd
|4.2.2|ADDW and SUBW are RV64I-only instructions that are defined analogously
to ADD and SUB but operate on 32-bit values and produce signed 32-bit
results. Overflows are ignored, and the low 32-bits of the result is
sign-extended to 64-bits and written to the destination register.|{addw/subw}/cp_rs1_rs2_edges
|4.2.2|SLL, SRL, and SRA perform logical left, logical right, and arithmetic
right shifts on the value in register _rs1_ by the shift amount held in
register _rs2_. In RV64I, only the low 6 bits of _rs2_ are considered
for the shift amount.|{sll/srl/sra}/cp_rs1_rs2_edges
|4.2.2|SLLW, SRLW, and SRAW are RV64I-only instructions that are analogously
defined but operate on 32-bit values and sign-extend their 32-bit
results to 64 bits. The shift amount is given by _rs2[4:0]_.|{sllw/srlw/sraw}/cp_rs1_rs2_edges, cp_rs2
|4.3|RV64I extends the address space to 64 bits. The execution environment
will define what portions of the address space are legal to access.|untestable
|4.3|The LD instruction loads a 64-bit value from memory into register _rd_
for RV64I.|ld/cp_rd
|4.3|The LW instruction loads a 32-bit value from memory and sign-extends
this to 64 bits before storing it in register _rd_ for RV64I. The LWU
instruction, on the other hand, zero-extends the 32-bit value from
memory for RV64I. LH and LHU are defined analogously for 16-bit values,
as are LB and LBU for 8-bit values.|lb/cp_memval_byte, lbu/cp_memval_byte, lh/cp_memval_half, lhu/cp_memval_half, lw/cp_memval_word, lwu/cp_memval_word
|4.3|The SD, SW, SH, and SB instructions
store 64-bit, 32-bit, 16-bit, and 8-bit values from the low bits of
register _rs2_ to memory respectively.|{sd/sw/sh/sb}/cp_rs2_edges
|4.4|The additional computational instructions in RV64I expand both the
standard and custom HINT encoding spaces.|untestable
|===

[[t-I-normative-reserved]]
.I Reserved Behavior
[cols="1, 4, 2" options=header]
|===
|Unpriv Section|Normative Rule|Coverpoints
|4.2.1|SLLIW, SRLIW, and SRAIW encodings with
_imm[5] &#8800; 0_ are reserved.|cp_uimm_5.
See also Ssstrict in <<Ssstrict>>

|===
